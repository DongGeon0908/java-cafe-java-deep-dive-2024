# Week 9
> 드디어 책의 마지막..

### Java Memory Model

- 변수를 읽거나 쓰는 작업, 모니터를 잠그거나 해제하는 작업, 스레드를 시작하거나 끝나기를 기다리는 작업과 같이 여러가지 작업에 대해 자바 메모리 모델 JMM을 정의한다.
- JMM에서는 프로그램 내부의 모든 작업을 대상으로 미리 발생하느 부분 재배치 연산을 정의하고 있다.
- 하나의 변수를 두개 이상의 스레드에서 읽어가려고 하면서 최소한 하나 이상의 스레드에서 쓰기 작업을 하지만 쓰기 작업과 읽기 작업간에 미리 발생 관계가 갖춰져 있지 않은 경우에 데이터 경쟁 - 현상이 발생한다. - 이와 같은 데이터 현상이 발생하지 않는 프로그램을 올바르게 동기화된 프로그램이라고 말한다.
- 올바르게 동기화된 프로그램은 순차적 일관성을 갖고 있으며, 다시 말해 프로그램 내부의 모든 작업이 고정된 전역 순서에 global order 에 따라 실행된다는 것을 의미한다.
- 미리 발생 현상에 대한 규칙은 다음과 같다.

**발생 현황 규칙**

- 프로그램 순서 규칙: 특정 스레드를 놓고 봤을때 프로그램된 순서에서 앞서있는 작업은 동일 스레드에서 뒤에 실행되도록 프로그램된 작업보다 미리 발생한다
- 모니터 잠금 규칙: 특정 모니터 잠금 작업이 뒤이어 오는 모든 모니터 잠금 작업보다 미리 발생한다
- volatile 변수의 규칙: volatile 변수에 대한 쓰기 작업은 이후에 따라오는 해당 변수에 대한 모든 읽기 작업보다 미리 발생한다
- 스레드 시작 규칙: 특정 스레드에 대한 Thread.start 작업은 시작된 스레드가 갖고 잇는 모든 작업보다 미리 발생한다.
- 스레드 완료규칙: 스레드 내부의 모든작업은 다른 스레드에서 해당 스레드가 완료됐다는 점을 파악하는 시점보다 미리 발생한다. 특정 스레드가 완료됐는지 판단하는 것은 Thread.join 메소드가 리턴되거나 ThreadisAlive 메소드가 false 리턴하는지 확인하는 방법을 말한다
- 인터럽트 규칙: 다른 스레드를 대상으로 interrupt 메소드를 호출하는 작업은 인터럽트 당한 스레드에서 인터럽트 당했다는 사실을 파악하는 일보다 미리 발생한다.
- 인터럽트를 당했다는 사실을 파악하려면 interruptedException을 받거나 isInterrupted 메소드 또는 interrpeted 메소드를 호출하는 방법을 사용 할 수 잇다
- 완료 메소드 규칙: 특정 객체에 대한 생성메소드가 완료되는 시점은 완료 메소드가 시작하는 시점보다 미리 발생한다
- 전이성 : A가 B보다 미리 발생하고, B가 C보다 미리 발생한다면, A는 C보다 미리 발생한다.
- 작업이 부분적으로만 순서가 정해져 있다고 해도, 동기화 작업은 항상 완전하게 순서가 정해진 상태이다. 따라서 락을 확보한 이후에 연달아 일어나는 volatile 변수의 값을 읽는 작업에 대해 미리 발생 규칙을 적용하는 일도 충분히 가능한다.

**너무 어렵게 설명함**
```
쉽게 생각하면...

Java Memory Model(이하 JMM) 은 특정 순간에 어떠한 필드를 읽었을 때 우리가 어떠한 값을 관찰할 수 있는지를 설명하는 모델이다. JMM은 약한 메모리 모델을 기반으로 설계되었기 때문에 각각의 CPU core가 바라볼 수 있는 값이 다를 수 있고, 따라서 이를 적절하게 제어하는 규칙에 대한 specification을 제공한다.
```


![image](https://github.com/DongGeon0908/java-cafe-java-deep-dive-2024/assets/50691225/ed2c6256-8fa2-4446-ab78-23b2f7dfd526)


### 밸덩 정리
```
Q9. Java 메모리 모델(Jmm)이란 무엇입니까? 목적과 기본 아이디어를 설명합니다.
Java 메모리 모델은 17.4장 에서 설명한 Java 언어 사양의 일부입니다 . 여러 스레드가 동시 Java 애플리케이션에서 공통 메모리에 액세스하는 방법과 한 스레드의 데이터 변경 사항이 다른 스레드에 표시되는 방법을 지정합니다. 매우 짧고 간결하지만 JMM은 강력한 수학적 배경이 없으면 이해하기 어려울 수 있습니다.

메모리 모델의 필요성은 Java 코드가 데이터에 액세스하는 방식이 실제로 하위 수준에서 발생하는 방식이 아니라는 사실에서 발생합니다. 메모리 쓰기 및 읽기는 이러한 읽기 및 쓰기의 관찰 가능한 결과가 동일한 한 Java 컴파일러, JIT 컴파일러 및 심지어 CPU에 의해 재정렬되거나 최적화될 수 있습니다.

이는 대부분의 최적화가 단일 실행 스레드를 고려하기 때문에 애플리케이션을 여러 스레드로 확장할 때 직관에 반하는 결과를 초래할 수 있습니다(크로스 스레드 최적화 프로그램은 여전히 ​​구현하기 매우 어렵습니다). 또 다른 큰 문제는 현대 시스템의 메모리가 다층화되어 있다는 것입니다. 프로세서의 여러 코어는 플러시되지 않은 일부 데이터를 캐시나 읽기/쓰기 버퍼에 보관할 수 있으며, 이는 다른 코어에서 관찰되는 메모리 상태에도 영향을 미칩니다.

설상가상으로, 다양한 메모리 액세스 아키텍처가 존재하면 "한 번 작성하면 어디서나 실행"이라는 Java의 약속이 깨질 수 있습니다. 프로그래머에게는 다행스럽게도 JMM은 다중 스레드 응용 프로그램을 설계할 때 신뢰할 수 있는 몇 가지 보장을 지정합니다. 이러한 보장을 고수하면 프로그래머가 다양한 아키텍처 간에 안정적이고 이식 가능한 다중 스레드 코드를 작성하는 데 도움이 됩니다.

JMM의 주요 개념은 다음과 같습니다.

작업 - 변수 읽기 또는 쓰기, 모니터 잠금/잠금 해제 등과 같이 하나의 스레드에서 실행하고 다른 스레드에서 감지할 수 있는 스레드 간 작업입니다.
동기화 작업 , 휘발성 변수 읽기/쓰기 또는 모니터 잠금/잠금 해제와 같은 특정 작업 하위 집합
프로그램 순서 (PO), 단일 스레드 내에서 관찰 가능한 전체 작업 순서
SO( 동기화 순서 ), 모든 동기화 작업 간의 전체 순서 - 프로그램 순서와 일치해야 합니다. 즉, PO에서 두 동기화 작업이 차례로 발생하면 SO에서도 동일한 순서로 발생합니다.
모니터 잠금 해제 및 동일한 모니터 잠금(다른 스레드 또는 동일한 스레드에서)과 같은 특정 동기화 작업 간의 SW(동기화) 관계
순서 전 발생 — PO와 SW를 결합하여( 집합 이론에서는 전이적 폐쇄 라고 함 ) 스레드 간 모든 작업의 ​​부분 순서를 만듭니다. 한 작업이 다른 작업 보다 먼저 발생 하면 첫 번째 작업의 결과를 두 번째 작업에서 관찰할 수 있습니다(예를 들어 한 스레드에서 변수를 쓰고 다른 스레드에서 읽는 경우).
발생 전 일관성 — 모든 읽기가 발생 전 순서에 따라 해당 위치에 대한 마지막 쓰기를 관찰하거나 데이터 경합을 통한 다른 쓰기를 관찰하는 경우 일련의 작업은 HB 일관성입니다.
실행 — 순서가 지정된 특정 작업 집합과 그 사이의 일관성 규칙
특정 프로그램에 대해 다양한 결과로 여러 가지 실행을 관찰할 수 있습니다. 그러나 프로그램이 올바르게 동기화 되면 모든 실행이 순차적으로 일관된 것으로 나타납니다 . 즉, 멀티스레드 프로그램을 순차적 순서로 발생하는 일련의 작업으로 추론할 수 있습니다. 이렇게 하면 내부 재정렬, 최적화 또는 데이터 캐싱에 대해 생각하는 수고를 덜 수 있습니다.
```



### Reference
- https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html
- https://www.baeldung.com/java-concurrency-interview-questions
- https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4
- https://codegym.cc/ko/quests/lectures/ko.questservlets.level18.lecture02
- https://download.oracle.com/otndocs/jcp/memory_model-1.0-pfd-spec-oth-JSpec
