# Week 1

---

### 목차

- 1장 개요
- 2장 스레드 안전성
- 3장 객체공유

---

## 1장 개요

- 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사
- 1.2 스레드의 이점
- 1.3 스레드 사용의 위험성
- 1.4 스레드는 어디에나

<br>
---
<br>

## 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사

> 초창기에는 컴퓨터에는 운영체제 자체가 없었음 당시 컴퓨터는 처음부터 끝까지 하나의 프로그램을 실행하기만함
> 해당 프로그램을 실행하기만 했고 해당 프로그램은 컴퓨터 내 모든 자원을 직접 접근할수있었음

- 운영체제 없이 하드웨어 위에서 바로 실행되는 프로그램은 작성하기도 힘듬
- 한번에 프로그램 하나만 실행하느니라 컴퓨터자원 대비 성능은 상당히 비효율적

운영체제는 여러개의 프로그램을 각자의 프로세스 내에서 동시에 실행 할수 있도록 발전
프로세스는 각자가 서로 격리된채로 독립적으로 실행하는 프로그램
운영체제는 프로세스마다 메모리, 파일핸들, 보안 권한등의 자원을 할당
프로세스끼리는 서로 통신 할 수도 있음 소켓, 시그널 핸들러, 공유메모리, 세마포어, 파일등 비교적 큰단위의 다양한 통신 수단 제공

여러 프로그램을 동시에 실행 할 수있는 운영체제를 개발하게 된 몇가지요인은 다음과 같음

- 자원활용: 하나의 프로그램이 기다리는 동안 다른 프로그램을 싱핼 할 수 있도록 지원하는편이 효율적

- 공정성: 여러 사용자와 프로그램이 컴퓨터 내 자원에 대한 동일한 권할을 가질 수 있다 
  한번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른프로그램을 시작 하는것보다는 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직함

- 편의성: 때론 여러 작업을 전부 처리하는 프로그램 하나를 작성하는것보다 각기 일 하나씩 처리하고 필요할때 프로그램 간에 조율하는 프로그램을 여러개 작성하는 편이 더 쉽고 바람직함 

초기 시분할 시스템에서는 각 프로세스가 가상적인 폰 노이만 컴퓨터 순차적으로 수행
순차적 프로그래밍 모델은 사람이 생각하는 방식과 같아서 직관적이고 자연스러움
대부분 한번에 한가지씩 순서대로 처리함

자원활용, 공정성 , 편의성등 프로세스의 개념을 만들어내게 된것과 같은 같은 동기를 가지고 스레드가 고안됨
스레드로 인해 한 프로세스 안에서 여러개의 프로그램 제어 흐름이 공존 할 수 있음

스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유한다.
하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역변수를 갖는다.

또한 프로그램을 스레드로 분리하면 멀티프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용 할 수 있다.
즉 한 프로그램내 여러 스레드를 동시에 여러개의 CPU 에 할당해 실행 시킬수 있다.

스레드를 가벼운 프로세스라고 부르기도 함
현대 운영체제 대부분은 프로세스가 아니라 스레드를 기본단위로 CPU 자원의 스케줄을 정함
의도적으로 조율하지 않는 이상 하나의 스레드는 다른 스레드와 상관없이 비동기적으로 실행됨

스레드는 자신이 포함된 프로세스 메모리 주소 공간을 공유하기떄문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙에 객체를 할당한다.
이 때문에 프로세스 때 보다 더 세밀한 단위로 데이터 공유 가능함
공유 된 데이터에 접근하는 과정을 적절하게 동기화 하지 않으면 다른 스레드가 사용중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수 있다.

--> 공유자원 문제

<br>
---
<br>

## 1.2 스레드의 이점

- 스레드를 제대로 사용하면 개발 및 유지 보수 비용 줄임 
- 복잡한 애플리케이션의 성능 향상
- 비동기적인 일 흐름을 거의 순차적으로 변경할 수있어 사람이 일하고 상호작용하는 방식을 모델링 하기 쉬어짐
- 서버 애플리케이션에 자원 활용도와 처리율을 높이는데 유용함
- JVM을 더 단순하게 구현 할 수 있도록 도와줌

**멀티프로세서 활용**

- 프로세서 스케줄링의 기본단위는 스레드이기 떄문에 스레드 하나로 동작하는 프로그램은 한번에 최대 하나의 프로세서만 사용한다.
- 활성 상태인 스레드가 여러 개인 프로그램은 여러 프로세서에서 동시에 실행 될 수 있음
  - 제대로 설계한다면 멀티스레드 프로그램은 가용한 프로세서 자원을 더 효울적으로 이용해서 처리 속도를 높일 수 있음
- 여러개의 스레드를 사용하면 프로세서가 하나라 해도 처리 속도 높일수 있음 (스레드 하나가 block되어도, 다른 스레드는 일할 수 있어서!)

**단순한 모델링**

- 종류별 작업마다 또는 시뮬레이션 작업의 각 요소마다 스레드를 하나씩 할당하면 마치 순차적인 작업처럼 처리 할 수 있음
- 스케쥴링 교차실행되는 작업, 비동기I/O, 자원대기등의 세부적인 부분과 상위의 비즈니스 로직에 해당하는 부분을 분리 할 수 있다.
- 다시 말해 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇개로 나눌 수 있다.
- 이런 장점servlet 이나 Remote method Invocation 와 같은 프레임워크에서 종종 활용

> 특정 I/O 요청에 대해서 프렘워크에서 작업을 별도의 스레드에 격리해서 처리.

**단순한 비동기 이벤트** 

- 여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업 쉬워짐

(Tomcat의 기본 스레드..200..)

더 빨리 반응하는 사용자 인터페이스

<br>
---
<br>

## 1.3 스레드 사용의 위험성

~~~java
@NotThreadSafe
public class UnsafeSequence{
    private int value;

    /** 유일한 값을 리턴 */
    public int getNext(){
        return value++;
    }
}
~~~

- 위에 코드 스레드에 안전하지 않은 일련번호 생성 코드이다!
- 재수없게 동시에 실행되는 경우 양쪽이 같은 값을 가져올 수 있음
- 경쟁조건(Race Condition)이라고 하는 흔한 위험성을 보여주는 예제
- 원래 설계한대로면 계속 다른 값을 리턴해야하지만 어떻게 간섭하느냐에 따라 결곽가 달라짐
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용중일지도 모르는 변수를 읽거나 수정 할 수 있음
 - 이점은 편리하지만 위험 할요소임


 위와 같은 코드 아래와 같이 변경하면 스레드 세이프해짐

 ~~~java
@ThreadSafe
public class Sequence{
    @GuardedBy("this") private int value;

    public synchronized int getNext(){
        return value++;
    }
}
 ~~~

- 자바에서는 공유 변수 접근을 조율하기 위해 동기화 수단 제공됨 
- synchronized 키워드를 넣어서 동기화 된 메소드로 만들면 문제 해결됨

동기화를 하지 않으면 컴파일러, 하드웨어, 실행 환경 각각에서 명령어의 실행시점이나 실행 순서를 자유롭게 조정 할 수있음
레지스터나 다른 스레드에 일시적으로 보이지 않는 프로세서별 캐시 메모리에 변수를 캐시 할 수 도있음
-> 성능을 향상하는데 도움이 되고 바람직하기도 한다
-> 하지만!!! 프로그래머 입장에서는 이런 최적화 작업 댸문에 프로그램에 오류가 발생하지 않도록 스레드간에 데이터가 공우되고 있는지를 명확하게 구분해 줘야하는 부담을 떠안아야함

**활동성 위험**

- 동시 수행 코드를 개발할 떄는 반드시 스레드 안정성 문제를 신경 써야함
- 프로그램 작성시 단일,멀티 안전성과 정확성을 유지하도록 작성돼야 함
- 멀티 스레드 프로그래밍 시 활동성  장애가 생길 수 있음
  - ex) 데드락(deadlock) 소모상태(starvation) 라이브락(livelock) 
    -> 10장에서 위와같은 문제 해결방법 자세히 다룸

**성능위험**

- 잘 설계된 병렬 프로그램은 스레드를 사용하여 궁극적으로 성능 향상시킬 수 있음
- 하지만 스레드를 사용하면 실행중에 어느정도 부하가 생김 스레드가 많은 프로그램은 컨텍스트 스위칭이 더 빈번하고 그때문에 상당한 부담
- 실행중인 컨텍스트를 저장하고 다시 읽어 들여야 하며 메모리를 읽고 쓰는데 있어 지역성이 손실되고 스레드를 실행하기도 버거운 CPU 시간을 스케줄링 하는데 소모
- 스레드가 데이터 공유 할때는 동기화 수단도 사용하여함 이러한 동기화는 컴파일러 최적화 방해, 메모리 캐시를 지우거나 무효화 하기도 함
- 그밖에 공유 메모리 버스에 동기화 관련 트래픽 유발 이러한 모든 요인은 측면에서 추가적인 손실 유발
  -> 11장에서 이런문제 자세히 다룸


<br>
---
<br>


## 1.4 스레드는 어디에나

모든 자바 프로그램은 기본적으로 스레드를 사용한다.
JVM을 시작시키면 main 메소드를 실행 할 주 스레드 뿐만 아니라 가비지 컬렉션이나 객체 종료 object finalization 와 같은 JVM 내부 작업을 담당할 스레드도 생성한다.

프레임웍은 프로그램 컴포넌트를 호출 할 때 프레임 웍 내부의 스레드에서 호출하기 때문에 자동으로 프로그램이 스레드를 활용하는 것과 동일한 효과를 준다
컴포넌트는 언제나 프로그램 내부의 상태에 접근하기 때문에 해당 상태에 접근하는 모든 코드 경로에 해당하는 컴포넌트 역시 스레드 안전해야 한다.

- 타이머
- 서블릿과 JSP
- 원격메소드호출(Remote Method Invocation)
- 스윙과 AWT

<br>
---
<br>

## 2장 스레드 안전성

- 2.1 스레드 안정성이란?
- 2.2 단일 연산
- 2.3 락
- 2.4 락으로 상태 보호하기
- 2.5 활동성과 성능

## 2.1 스레드 안정성이란?

- 스레드에 안전해야 하느냐는 해당 객체에 여러 스레드가 접근할지 여부에 달렸다.
- 객체를 스레드에 안전하게 만들려면 동기화를 통해 변경할 수 있는 상태에 접근하는 과정을 조율해야 한다
- 동기화가 제대로 되지 못하면 데이터가 손상되거나 기타 바람직하지 않은 여러가지 결과가 생길 수 있다.
- 스레드 하나 이상 상태 변수에 접근하고 그중 하나라도 변수에 값을 쓰면 해당 변수에 접근할때 관련된 모든 스레드가 동기화를 통해 조율해야 한다.
- 자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공
- volatile 변수, 명시적인 락, 단일 연산 변수(automic variable) 사용하는 경우에도 동기화라는 용어를 사용한다.

만약 여러스레드가 변경 할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그프로그램은 잘못된것이다.
고치는데는 3가지 방법이 있음

**
1. 해당 상태 변수를 스레드 간에 공유하지 않거나
2. 해당 상태 변수를 변경 할 수 없도록 만들거나
3. 해당 상태 변수에 접근할땐 언제나 동기화를 사용한다.**


**스레드 안전한 클래스를 설계할땐 바람직한 객체 지향 기법이 왕도, 캡슐화와 불변객체를 잘 활용하고 불변 조건을 명확하게 기술 해야 한다.**

스레드 안전성을 정의하기는 까다로움
스레드 안전성에 대한 정의가 모호한것은 정확성에 대한 명확한정의가 없기때문임
여러 스레드가 클래스에 접근할대 계속 정확하게 동작하면 해당 클래스는 스레드에 안전하다

~~~
여러 스레드가 클래스에 접근할때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.
~~~

~~~
스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.
~~~

**상태 없는 서블릿**

~~~java
@ThreadSafe
public class StatelessFactorizer implements Servlet{
    public void service(ServletRequest req, ServletResponse reps){
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors= factor(i);
        encodeIntoResponse(reps,factors);
    }
}
~~~

- StatelessFactorizer 대부분의 서블릿처럼 상태가 없다
- 선언한 변수도 없고 다른 클래스의 변수를 참조하지도 않음
- 특정한 계산을 위한 일시적인 상태의 스레드의 스택에 저장되는 지역변수에만 저장하고, 실행하는 해당 스레드에서만 접근 할 수 있음
- 따라서 StatelessFactorizer 접근하는 특정 스레드는 같은 StatelessFactorizer에 접근하는 다른 스레드에 영향을 줄수 없음
- 두 스레드가 상태를 공유하지 않기 때문에 사실상 서로다른 인스턴스에 접근하는것과 같다
- 상태가 없는 객체에 접근하는 스레드가 어떤 일을 핟근 다른 스레드가 수행하는 동작의 정확성에 영향을 끼칠 수 없기 때문에 상태없는 객체는 항상 스레드에 안전하다.

<br>
<hr>
<br>

## 2.2 단일 연산

경쟁조건

~~~java
@NotThreadSafe
public class UnSafeCountingFactorizer implements Servlet{
    private long count = 0;

    public log getCount(){ return count; }

    public void service(ServletRequest req, ServletResponse reps){
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors= factor(i);
        ++count;
        encodeIntoResponse(reps,factors);
    }
}
~~~

- UnSafeCountingFactorizer 에는 여러 종류의 경쟁 조건이 발생 할 수 있기 때문에 결과를 신뢰 할 수 없음
- 경쟁조건, 데이터 경쟁 혼동되는 용어임
- 경쟁 조건 : 상대적인 시점이나 또는 JVM 이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질때 나타난다. 다시말하면 타이밍이 딱 맞았을때만 정답을 얻는 경우를 말한다.
- 데이터 경쟁: 공유된 final 이 아닌 필드에 대한 접근을 동기화로 보호하지 않았을때 발생한다. 스레드가 다음 스레드가 읽을 수 있는 변수에 값을 쓰거나 다른 스레드가 마지막에 수정 했을 수도 있는 변수를 읽을떄 두 스레드 모두 동기화하지 않으면 데이터 경쟁이 생길 위험이있다. 
- 위의 코드 경쟁조건, 데이터 경쟁 모두 가지고있음


**늦은 초기화시 경쟁조건**

~~~java
@NotThreadSafe
public class LazyInitRace{
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance(){
        if(instance == null){
            intance = new ExpensiveObject();
        }
        return instance;
    }
}
~~~

- LazyInitRace는 경쟁 조건 때문에 제대로 동작하지 않을 가능성이 있다. 
- 스레드 A 와 B 가 동시에 getInstance를 수행한다고하자, instance 라는 변수가 null 이라는 사실을 본 다음 스레드는 A 는 ExpensiveObject 의 인스턴스를 새로 생성한다 스레드 B도 instance 변수를 살펴본다. 이때 instance 가 null의 여부는 스케줄이 어떻게 변경될지 또는 스레드 A가 ExpensiveObject 인스턴스를 생성하고 instance 변수에 저장하기 까지가 얼마나 걸리는지등 예측하기 어려운 타이밍에 따라 달라진다.
- 원래 getInstance 는 항상 같은 인스턴스를 리턴하도록 설계돼 있는데 스레드 B가 살펴보는 그시점에서 instance 가 null 이면 getInstance 를 호출한 두스레드가 서로다른 인스턴스를 가져갈 수도 있다.
- 여러번 호출 할 때 서로 다른 저장 공간 인스턴스를 받으면 저장된 내용을 잃거나 여러스레드에서 객체 목록을 보려 할때 일관성이 전혀 없을수도있음
- 또한 지속 프레임워크에서 객체 식별자를 생성하는 부분에 UnsafeSequence 를 사용한다면 서로 완전히 별개인 두객체가 같은 식별자를 가질수 있기 때문에 객체 유일성에 대한 제약이 깨질 수 도 있다.

**복합동작**
경쟁조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정 할 때 다른 스레드는 수정 도중이아닌 수정이전이나 이후에만 상태를 읽거나 변경을 가할 수 있다.

- 자바에서 기본적으로 제공하는 락

~~~java
@ThreadSafe
public class CountingFactorizer implements Servlet{
    private final AtomicLong count = new AtomicLong(0);

    public log getCount(){ return count.get(); }

    public void service(ServletRequest req, ServletResponse reps){
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors= factor(i);
        count.incrementAndGet();
        encodeIntoResponse(reps,factors);
    }
}
~~~

- java.util.concurrent.atomic 패키지에는 숫자나 객체 참조 값에 대한 상태를 단일 연산으로 변경 할 수 있도록 단일연산 변수 atomic variable 클래스가 준비돼 있다.
- long -> AtomicLong  이제 카운터에 접근하는 모든 동작이 단일 연산으로 처리 된다.
- 서블릿 상태가 카운터의 상태이고 카운터가 스레드에 안전하기 때문에 서블릿도 스레드에 안전하다.
- 상태 없는 클래스에 상태 요소를 하나 추가 할때 스레드 안전한 객체 하나로 모든 상태를 관리한다면 해당 클래스는 스레드에 안전하다

~~~
가능하면 클래스 상태를 관리하기 위해 AtomicLong 처럼 스레드에 안전하게 이미 만들어져 있는 객체를 사용하는 편이 좋다. 
스레드에 안전하지 않은 상태 변수를 선언해두고 사용하는것보다 이미 스레드 안전하게 만들어진 클래스가 가질 수 있는 가능한 상태 변화를 파악하는편이 훨씬 쉽고 스레드 안전성을 더 쉽게 유지하고 검증 할 수 있다.
~~~

### Atomic 구현 관련하여..

java의 AtomicInteger는 Cas 알고리즘을 따른다.

![image](https://github.com/DongGeon0908/java-cafe-java-deep-dive-2024/assets/50691225/dc70da37-6852-4316-a939-c4ba6a37e6e4)

Atomic, Adder, Accumulator 등의 기술 존재


<br>
<hr>
<br>

## 2.3 락

~~~java
@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {
    private final AtomicReference<BigInteger> lastNamber = new AtomicReference<BigInteger>();
    private final AtomicReference<BigInteger []> lastFactors = new AtomicReference<BigInteger []>();

    public void service(ServletRequest req, ServletResponse reps){
        BigInteger i = extractFromRequest(req);
        if(i.equals(lastNumber.get()))
            encodeIntoResponse(reps,factors);
        else{
            BigInteger[] factors= factor(i);
            lastNamber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(reps,factors);
        }

    }
}
~~~

- 단일 연산 참조변수 각각은 스레드에 안전하지만 UnsafeCachingFactorizer 틀린결과를 낼 수 있는 경쟁조건을 가지고 있음
- 스레드 안전성 정의에 따르면 여러 스레드에서 수행되는 작업의 타이밍이나 스케줄링에 따른 교차 실행와 관계 없이 불변 조건이 유지돼야 스레드에 안전하다. 
- 여러개의 변수가 하나의 불변 조건을 구성 하고 잇다면 이변수들은 서로 독립적이지 않다. 한 변수의 값이 다른 변수에 들어 갈 수 있는 값을 제한 할 수 있다. 따라서 변수 하나를 갱신 할땐 다른 변수도 동일한 단일 연산 작업 내에서 함께 변경해야한다.
- 타이밍이 좋지 않았다면 UnsafeCachingFactorizer 불변 조건이 깨질 수 있음
- lastNamber, lastFactors 두개의 값을 동시에 갱신하지 못한다.
- **상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.**

**암묵적인 락**

- 자바는 단일 연산 특성을 보장하기위해 synchronized 라는 구문을 사용 할 수 있는 락을 제공한다.
- synchronized 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다.
- 메소드 선언 부분에 synchronized 키워드를 지정하면 메소드 내부의 코드 전체를 포함하면서 메소드가 포함된 클래스의 인스턴스를 락으로 사용하는 synchronized 블록을 간략하게 표현한것으로 볼수 있다
- static 으로 선언된 synchronized 메소드는 해당 class 객체를 락으로 사용한다.

~~~java
synchronized (lock){
    // lock 으로 보호된 공유 상태에 접근하거나 해당 상태를 수정한다.
}
~~~

- 모든 자바 객체는 락으로 사용 할 수 있다.
- 이와 같이 자바에 내장된 락을 암묵적인락 intrinsic lock 혹은 모니터 락 monitor lock 이라고 함
- 락은 스레드가 synchronized 블록에 들어가기전에 자동으로 확보되며 정상적으로든 예외가 발생해서든 해당 블록을 벗어 날때 자동으로 해제된다.

~~~java
@ThreadSafe
public class SynchronizedgFactorizer implements Servlet {
    @GuardedBy private BigInteger lastNamber;
    @GuardedBy private BigInteger[] lastFactors;

    public synchronized void service(ServletRequest req, ServletResponse reps){
        BigInteger i = extractFromRequest(req);
        if(i.equals(lastNumber.get()))
            encodeIntoResponse(reps,factors);
        else{
            BigInteger[] factors= factor(i);
            lastNamber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(reps,factors);
        }

    }
}
~~~

- 스레드에 안전하다
- 위처럼 코드 작성하면 안됨...!!!! 엄청 느림 
- synchronized 키워드를 통해서 특정 락으로 보호된 코드 블록은 한번에 한 스레드만 실행 할 수 있기 때문에 느리다
- synchronized 블록이 실행중이라면 같은 락으로 보호되는 synchronized 블록에 다른 스레드가 들어와 있을 수 없다.

**재진입성**

- 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는것을 의미한다.
- 재진입성을 구현하려면 각 락마다 확보횟수와 확보한 스레드를 연결시켜둔다.
- 확보 횟수가 0이면 락은 해제된 상태 
- 스레드가 해제된락을 확보하면 JVM 이 락에 대한 소유 스레드를 기록하고 확보 횟수를 1로 지정한다.
- 같은 스레드가 락을 다시 얻으면 횟수 증가 소유한 스레드가 synchronized 블록 밖으로 나가면 횟수 감소

~~~java
public class Widget{
    public synchronized void doSomething(){
        ...
    }
}

public class LoggingWidget extends Widget{
   public synchronized void doSomething(){
       System.out.println(toString()+": calling doSomething");
       super.doSomething();
   }
}
~~~

- 암묵적인 락이 재진입 가능하지 않았다면 데드락에 빠졌을 코드
- 둘다 synchronized 로 선언되어있고 각각 진행하기전에 Widget 에 대한 락을 얻으려고 시도
- 하지만 암묵적인 락이 재진입 가능하지 않았다면 이미 누군가 락을 확보했기 때문에 super.doSomething 호출에서 락을 얻을수 없게되고 결과적으로 확보할 수 없는 락을 기다리면서 영원히 멈춰있을거임
- 재진입성은 이런 경우에 데드락에 빠지지 않게 해준다.



<br>
<hr>
<br>

## 2.4 락으로 상태 보호하기

- 여러 스레드에서 접근 할 수 있고 변경가능한 모든 변수를 대상으로 해당 변수에 접근 할때는 항상 동일한 락을 먼저 확보한 상태여야 한다.
  이경우 해당 변수는 확보된 락에 의해 보호된다고 말한다.

- 모든 변경 할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 한다.
  유지 보수하는 사람이 알수 있게 어느 락을 보호하고 있는지를 명확하게 표시하라

- 여러 변수에 대한 불변조건이 있으면 해당 변수들을 모두 같은락으로 보호해야한다.


<br>
<hr>
<br>

## 2.5 활동성과 성능

~~~java
@ThreadSafe
public class CacheFactorizer implemnts Servlet{
    @GuardedBy("this") private BigInteger lastNamber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    @GuardedBy("this") private long hits;
    @GuardedBy("this") private long cacheHits;

   // 변경 할 수 있는 공유 상태에 속하기 때문에 접근 할 때 항상 동기화 구문 사용
   public synchronized long getHits() { return hit; }

   // 변경 할 수 있는 공유 상태에 속하기 때문에 접근 할 때 항상 동기화 구문 사용
   public synchronized double getCacheHitRatio(){
       return (double) cacheHits  / (double) hits;
   }
   
    public void service(ServletRequest req, ServletResponse reps){
        /**  synchronized 블록 밖에 있는 코드는 스레드와 공유되지 않는 지역(스택상의) 변수만 필요하기 떄문에 동기화 필요없음 */
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        
        /** 캐시된 입력값과 결과를 새로운 값으로 변경하는 부분 
        덤으로 접속 카운터를 다시 넣고 캐시가 사용된 횟수를 세는 카운터 추가
        */
        synchronized (this){
            ++hits;
            if(i.equals(lastNumber)){
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        
        // 캐시된 결과를 가지고 있는지 검사 
        if(factors == null){
            factors = factor(i);
            synchronized (this){
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }

        encodeIntoResponse(reps,factors);
    }
}
~~~

- synchronized 블록으 범위를 줄이면 스레드 안전성을 유지하면서 쉽게 동시성을 향상 시킬 수 있다.
- synchronized 블록의 크기를 적정하게 유지하려면 안전성(절대 타협 X), 단순성, 성능등 서로 상충하는 설계 원칙 사이에 적절한 타협이 필요 할 수 있음
- **종종 단순성과 성능이 서로 상출 할 때가 있음 동기화 정책을 구현할 떄는 성능을 위해 조급하게 단순성(잠재적으로 안전성을 훼손하면서)을 희생하고픈 유혹을 버려야한다.**
- **복잡하고 오래 걸리는 계산작업, 네트웍 작업, 사용자의 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 락을 잡지 말아라**

### Syncronized 동작 원리

- monitor를 Lock하여 block mehotd를 하나의 스레드가 점유하여 사용
- monitor는 내부적으로 queue가 구현되어 있고(wait,set), queue를 기반으로 특정 기능을 점유할 수 있다.
